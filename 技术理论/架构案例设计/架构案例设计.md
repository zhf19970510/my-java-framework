### 用户系统案例设计

用户注册和登录功能

用户他管理和自管理功能

权限管理功能

用户个人信息管理功能

与其他系统的整合功能



注册、登录：

用户数据的存储（存在不同的地方，数据同步，不同服务通过路由做，分流存）

数据一致性（防止重复注册）

1. 异地存储时，异地多活场景，可以采用二次读取方案，拉取其他地域注册数据，防止重复注册。

2. 还可以采用手机验证码和绑定第三方账号的方式来实现。但是如何使用第三方账号的同时如何保证username是唯一的？如果要绑定的第三方账号需要进行切换，那么其实只是进行切换，不会绑定多个第三方账号。实际就是调用第三方服务来保证唯一性。

3. 或者采用先让其允许注册，后期合并的方案。

   数据合并：1. 基于版本；2. 基于时间戳

4. 还可以使用验证码

数据隐私和安全

 1. 存储

    过敏存储：对称加密、非对称加密、hash。（混淆、编码、压缩）

    对称加密：加密和解密用的同一个秘钥。如手机号在数据库中的存储。身份证号，银行卡号。优先选择对称加密，因为对称加密效率高。为了安全选择非对称加密，为了效率选择非对称加密算法。

    非对称加密：加密和解密都需要用秘钥，非对称加密有两个秘钥，一个是公钥，一个是私钥。用公钥加密生成秘文，用私钥针对秘文进行解密。或者用私钥加密的秘文用公钥进行解开。如手机号在数据库中的存储。身份证号，银行卡号。

    hash（散列）加密：是一种不可逆的加密。明文通过散列的运算算法，变成一个秘文，是不可以被解密回去的。MD5类似于一种hash（散列）的算法。比如说存储密码。

 2. 传递（不被人看，不被人改）HTTPS POST ，如果请求参数一定要出现在url中，则可以进行加盐（签名，验签），防止被别人修改。

 3. 使用（避免sql注入）a用户的订单被b用户看到或操作？要判断当前订单归属用户是不是当前操作用户的。

防止恶意注册（如注册机器人、批量注册等）

​	验证码，黑名单（60秒内只能注册一次，收一次验证码，限制频率），实名认证，第三方认证审核或者人工审核机制。

登录后的认证

​	session

​	token

​	可以使用签名防篡改

控制权的问题

​	谁控制、认证的凭证需要谁掌握。单点登录、推送。- 设置token过期时间

​	单点登录实现思路：后端用一个key-value的结构存储用户和token的对应关系，用户为key，token为value。当用户携带token发出请求时，先解析token，从token中解析出用户id，然后根据用户id找到服务器存储的token，比对两边token是否一致，不一致则要求客户端重定向到登录页进行重新登录。

认证共享的问题（session, token)

​	sessionId共享

​	session共享

​	token共享



用户系统的开放平台设计：

​	设计API: 支持基本的用户数据的写入、查询。

​	授权：appkey, appsecret

​	收费：调用一次扣一次费用

​	开发文档和sdk。





签名和验签示例：

![image-20240928220700326](https://gitee.com/zhf19970510/image-server/raw/master/img_2024/202409282207506.png)



### 网关系统设计

网关系统是指处于系统架构中，作为应用程序和外部系统之间的接口，负责协调和转发请求和响应的系统。

位于客户端和服务端之间的一种中间层系统，请求在这里过一遍水。

​		本质：过滤器



网关-功能

路由转发：将来自客户端的请求，按照预先定义的路由规则进行转发，使请求能够到达正确的后端服务。包括：请求的地址、方法、参数等信息。

协议转换：支持多种协议，如HTTP、Websocket、gPRC等，并进行协议转换。

安全控制：根据定义的策略，对请求进行安全控制，比如请求的身份验证、加解密，黑名单、限流、鉴权等。

流量控制：对请求进行限流、熔断、降级等操作，保证系统的稳定性。

缓存：对热点数据进行缓存，减轻后端服务的压力，提高系统的性能。



安全控制：

鉴权：用户认证（未经授权的访问），权限判断。

加解密：外部加密数据，内部明文调用，扩展https。

黑名单：ip、设备、用户。

限流：计数器。

对称加密效率高，非对称加密效率低，可以采用非对称加密的方式，将对称加密的秘钥传输到服务端，然后所有请求都通过对称加密的方式进行传输，这样就不会有安全问题，只要做到下载客户端的时候，给不同客户端生成的对称加密秘钥不一致即可。



网关黑名单：

黑名单作用：

黑名单存储：（配置文件，数据库，缓存）

黑名单更新（实时更新 ：缓存，钩子webhooks，消息队列）：

请求过滤和拦截：（HttpServletRequest 403 Forbiden）

日志与监控：（mysql, elk, prometheus 调整策略，禁止游客模式）



网关：流量控制

限流：限制客户端在特定时间内发起的请求数量

熔断：当后端服务出现异常或者响应时间过长时，熔断器会拦截请求，直接返回错误或者默认值，防止请求继续传递到后端服务。熔断器可以根据一定的自动恢复，例如在一段时间后重试或者根据成功率进行判断。

降级：根据系统的负载情况，动态调整提供的服务质量。例如，当系统压力较大时，可以关闭一些非关键性功能，或者返回简化的响应数据。降级可以手动触发，也可以根据监控数据自动触发。

负载均衡：将请求分发到多个后端服务实例，以确保每个实例的负载均衡。负载均衡算法包括轮询、随机、加权轮询、最少连接数等。负载均衡可以在网关层实现，也可以通过DNS、负载均衡器等其他组件实现。

优先级调度：根据请求的优先级，动态调整请求的处理顺序。例如，可以为付费用户、实时性要求高的请求分配更高的优先级。优先级调度可以结合队列、堆等数据结构实现。

请求拦截：基于黑名单、白名单、访问控制列表（ACL）等规则，拦截不符合要求的请求。请求拦截可以防止恶意流量、爬虫等对系统造成压力。



限流依据：

IP、设备、用户、API接口、地理位置、请求方法。 429 too many request



限流算法：

固定时间窗口

滑动时间窗口

令牌桶算法：固定容量的计数器（囤可用的）

漏桶算法：固定长度的队列（记已经使用的请求数）



网关：缓存

访问频繁的接口（缓存，带过期时间）、

响应时间较慢的接口、需要频繁访问的静态资源。



### 订单系统设计

核心业务

架构设计

1. 模块化
2. 高内聚低耦合
3. 可扩展性
4. 高可用性

技术实现



可扩展性：

水平扩展：无状态、负载均衡

微服务

数据库拆分

异步处理or消息队列



可用性：（正常运行的时间/测试的总时间） * 100%；



系统之间的调用方式对可用性的影响。



扩展：

串行系统、并行系统

串行系统：系统中各个组件按照顺序连接，任何一个组件出现故障，都会导致整个系统的失效。整个系统可用性为各个系统可用性相乘。

并行系统：只要有一个可用，整个系统都可用。整体可用性 = 1 - （1-系统1）*（1-系统2）*（1-系统3）*...*(1 - 系统n)



高可用方案：

1. 提高组件的可靠性：选择高可用的硬件和软件的组件；（可以考虑选择云服务）
2. 冗余设计&容错。（副本，主从切换）
3. 负载均衡和故障切换。
4. 微服务架构：熔断、降级（异步、解耦、削峰）
5. 监控与告警：perl写程序监控服务器硬件的运行
6. 过载保护

异步（解耦），集群，分布式，缓存，限流，备份，降级，预热，熔断



SPU（Standard Product Unit）：将一类相似的商品归为一组的概念。便于商品的分类、筛选和展示，有利于消费者找到所需的产品。

SKU（Stock keeping Unit）：库存管理的基本单位，一个sku就代表一个具体的商品规格。sku要精确地跟踪商品的库存，便于库存管理，销售统计。

关系：

spu:sku:

1-1:简单。全世界就一个

1-多：iphone: iphone 白 8g。

多-1：spu：男七分裤夏季薄款休闲，男士宽松大码潮裤。对应的sku是1个。用在营销上。

组合sku：sku-桌子，sku-凳子。

中式餐桌组合sku： 1sku-桌子+4sku-凳子。

组合的话可以减少计算量，不组合的话要看具体的sku剩余量，计算量多一些。



编码设计

学会唯一标识设计，以及如何校验唯一标识。

spu编码设计：
类别代码：用于表示商品所属的大类别，如服装、电子产品等。

品牌代码：用于表示商品所属的品牌。

系列代码：用于表示商品所属的产品系列。

序列号：用于表示同一类商品的不同型号或版本。

例如，假设我们为一款电子产品指定SPU编码。类别代码为“01”（表示电子产品），品牌代码为“02”（表示品牌B），系列代码为“03”（表示为系列C），序列号为“0001”，则该商品的SPU编码为：010203001.

SKU编码设计：

SKU编码中包含对应商品的SPU编码，以便于关联和查询。

属性代码：用于表示商品的各种规格属性，如颜色、尺寸等。属性代码可以分为多个字段，分别表示不同的属性。

序列表：用于表示同一商品规格的不同批次或生产日期等信息。

例如，假设我们为上述电子产品的某个规格（颜色为红色，尺寸为大）指定SKU编码，属性代码为“01”（表示红色）和“02”（表示大尺寸），序列号为“001”，则该商品规格的SKU编码为：010203001-0102001.

商品设计：

商品是订单的基础

不同系统中商品是不一样的，订单也是不一样的。

共性+个性=唯一：属性之和=sku

唯一+扩展=类别：sku+抽象=spu

类目设计：

category_id: 类目ID，是每个类目的唯一标识，通常设为主键。

category_name: 类目名称，是用户在界面上看到的类目名字。

parent_id: 父类目ID，用来表示这个类目的上一级类目。如果这个类目是最顶级的类目，那么这个字段可以为空或者设为0。

level: 类目级别，用来表示这个类目在类目层级中的位置。最顶级的类目的级别为1，其下一级的类目级别为2，依次类推。

status: 类目状态，用来表示这个类目是否可用，例如，可以设1表示可用，0表示不可用。

sort_order: 排序顺序，用来表示在同一层级的类目中，这个类目的排序位置。

品牌库：
branch_id: 品牌ID,每个品牌的唯一标识符，通常设为主键。

branch_name: 品牌名称，用于显示的品牌名。

branch_logo: 品牌LOGO的URL，用于在页面上展示品牌的Logo。

branch_website: 品牌的官方网站URL。

branch_description: 品牌描述，一段简短的文字描述这个品牌的特点和历史信息。

branch_status: 品牌状态，例如，可以设为1表示品牌可用，0表示品牌不可用。

sort_order: 排序顺序，用来控制品牌在页面上的显示顺序。 

为了让重要数据做到可以追溯，一般会对业务表加一张his表。否则，有纠纷的时候说不清楚。

属性设计：

attribute_id: 属性ID，为每个属性的唯一标识符，通常设为主键。

attribute_name: 属性名称，描述属性的类型（如颜色、尺寸等）。

attribute_type: 属性类型，用于描述属性值的类型，例如文本、数字、日期等。

关联：category_id: 分类ID，表示此属性与哪个商品类别相关联。这个字段可以帮助你将相应的属性分配给对应的商品类别。

属性和属性值：类和对象。

为了存储每个具体商品的属性值，你可能需要另一张表——商品的属性值表（Product Attribute Value Table）。这个表可能包含product_id（商品ID）和value（值）等字段，用于存储每个商品具有的特定属性值。

通用规格设计：

specification_id: 规格ID，为每个规格的唯一标识，通常设置为主键。

specification_name: 规格名称，例如“屏幕尺寸”、“存储容量”等。

specification_values: 规格值，一般以字符串数组或者其他形式存储可能的值，例如“32寸”，“64寸”等。

status: 状态，表示这个规格是否可用，可以设为1表示可用，0表示不可用。

属性是地基，规格是地基上面的衍生品。



第三方支付平台是向后端发送支付结果通知。

如果给前端发送，则需要做：消息重复发送、接口回查。比较麻烦。



商品列表设计：

功能上：

搜索和过滤

排序

商品信息展示（列表，图标）

个性化推荐

性能上：

分页&懒加载

压缩和解压

缓存：更新

缓存更新分为两大类：

主动更新：

1. 更新缓存更新数据库；（不可以）
2. 更新数据库，更新缓存；（不可以）
3. 删除缓存，更新数据库；（可以）
4. 更新数据库，删除缓存。（可以）延时双删

被动更新：自己过期自己失效，下次读的时候再来取。ttl

数据库优化（分库分表、索引，优化sql，正、反范式设计，在某些情况下，可以做适当的冗余、数据分区，读写分离，视图和存储过程。oracle中有一种物化视图能极大地提升性能，小缓存，8.0以上去掉了缓存，因为在多核环境下效率不高，并且很难预测它是不是很难预测，连接管理：连接池）

搜索引擎

CDN：减少直接从服务器的源站获取数据的频率。

技术的设计是依赖于业务的需求。满足业务的需求是最重要的。



商品详情设计：

每家公司针对用户的痛点是不一样的，所以导致它在设计商品详情页的时候设计出来的结果是不一样的。

考虑的点：

1. 减少cookie。在进行http请求时，许多不必要的cookie不必要用。如果将cookie作为一个缓存数据，那么每次请求都会随请求发送到服务器，增加了请求的数据量，增加了服务器的压力。
2. 图片压缩：thumbnailator。
3. js压缩，css压缩：删除无效字符，注释以及无效代码，以及代码语义的缩减。请求压缩
4. 减少请求：请求合并、雪碧图、svg，可以适当把计算能力转移到客户端去，将图片转换为base64.
5. cdn：可以把静态资源：图片、css、js缓存到离客户端最近的服务器上，从而减少延迟和加载的时间。 
6. 动静分离：
7. 异步加载：懒加载
8. 缓存：后端缓存、前端缓存：cache-control。开发小技巧：可以在页面响应后的地址输入拼接参数，如&a=fejifjeaiow或者修改文件名
9. 预加载：在当前页面提前对下一个页面的域名进行解析 <meta http-equiv="x-dns-prefetch-control" content="on">



购物车设计：

创建订单时为了防止超卖，减库存的时候需要加锁

可以考虑jvm锁、分段锁和分布式锁

锁失效如何解决？

比如使用redis加锁，如果redis是单机的，redis挂了就确实没办法了，但是也不会造成数据不一致的问题，都下不了单了。如果做成集群，需要保证加锁的key需要在集群之间进行同步，不然a加锁成功，b加锁也成功，其实还是加锁失败的。要解决这种情况，可以使用红锁。红锁主要就是去解决集群中redis节点数据同步的问题导致加锁失败。

可以使用的redis来做加锁的集群。当redis加锁的个数超过集群个数的一半，就说加锁成功。这样既规避了前面redis崩溃的问题，也规避了前面redis数据同步造成的问题。

订单ID(唯一性、可读性、安全性、扩展性)

UUID、数据库自增id（批量）、redis incr( by )：优点大于缺点，雪花算法，uidgenerator，Leaf



前端支付凭证处理：

接口抽象化，屏蔽底层细节



支付回调处理：

1. 重复通知机制；

2. 校对机制；-分布式事务方案的一种。

   实现方式：内部系统：（MQ)，外部系统（MQ+http）



订单状态变更：

连贯性

排他性

异常处理 tcc

扩展性：



库存扣减方案：

1. 下单扣库存。可能存在恶意抢单的情况；
2. 付款扣库存。可能会导致用户的体验感不好，在抢单进入到付款页面才提示库存不够了
3. 预留库存。过期操作。
4. 安全反作弊：对经常下单，不付钱的用户进行打标



订单拆单：

梳理好父子订单的关系：父订单Id，级别



库存分层：

销售层（用户）：查询、锁定、扣减、回滚

调度层（中间层）：库存同步，库存分配。

仓库层：+、- 核对

数据一致性：没法100%保证

并发：熔断、降级

安全与权限

为什么分层：

高内聚低耦合，分离关注点（系统边界）提高扩展性，可维护性好





### 开放平台设计

API的设计与管理：
restful设计，

api版本：url中，head：key是version；accept: application/供应商.接口.v1+json

无版本趋势：新版本兼容老版本

api文档

要素：协议、域名、路径、版本、动作：post,put修改（全量）,patch（局部）,delete,get





### 灰度发布





### 权限控制

基于角色的访问控制（RBAC）

 基于属性的访问控制（ABAC）：访问控制决策是基于属性的，这些属性可以关联到用户、访问资源、操作、环境

定义哪些属性的组合可以允许或者拒绝访问。

可以建立一张属性表、策略表和策略条件表来满足需求。

基于策略的访问控制（PBAC） 

![image-20241004093449359](https://gitee.com/zhf19970510/image-server/raw/master/img_2024/202410040934583.png)



基于上下文的访问控制（CBAC&CoBAC）

上下文：工作日（周一-周五）





### 限流与配额

避免服务收到过量的请求导致服务质量下降或者系统过载，还有就是为了开放平台多收点费用。

限流：针对每个用户或者注册到开放平台上的应用进行的。

固定时间窗口：统计；缺点：请求突刺

滑动时间窗口：成功率、平均响应时间RT

漏桶：

令牌桶：

配额：计数器 要么加，要么减，但是如果遇到大数据量的时候key就会特别多，可以做动态的设置，比如redis的getset，懒加载，请求来了，才给对应的key加上请求数1，并且设置该key1h后就去除该key。



### 中台：建、拆

中间：公共能力的沉淀。地图功能独立，开放，组合式创新，颠覆式创新，让中台变薄。





### 如何设计一款微信软件？

先说是不是，再说为什么、

不要一开始就追求完美，不要过度设计

目标是什么？

沟通聊天、微信公众号、朋友圈、支付、生活的方方面面。

怎么做？

微信沟通功能：

用户界面-UI、用户体验-UE、UX、

简单直观、一体化的服务



用户管理、

![image-20241004200255410](https://gitee.com/zhf19970510/image-server/raw/master/img_2024/202410042002852.png)

消息数据、

![image-20241004200723505](https://gitee.com/zhf19970510/image-server/raw/master/img_2024/202410042007164.png)

消息传递、

用户和用户之间如果只靠他们之间是极度不稳定的，会影响到消息的接收，

消息经过服务器，控制消息的传输，可以有效处理用户不在线的情况

共享位置，对讲功能：没有采用点对点的方式，还是采用了服务器中转的方式，避免客户端之间网络连接问题导致出现的问题，还有可以避免消息漏发的问题，尽量设计系统的时候避免使用p2p的模式。

好有关系用图数据库？

对于复杂的微信系统，不可能只是使用图数据库做存储。

一对一、一对多

微信架构演进中我们可以学习的经验？

消息的推送拉取模型

让服务器和设备之间尽可能少地传输数据，数据链路尽可能短，如何增量同步用户信息、好友、消息增量同步到另一台机器？

在客户端记录一个本地数据的快照，需要同步数据的时候，把快照也传递给服务器，服务器计算比对出数据差异，把差异发送给客户端。

快照随着时间的推移，越来越大

客户端每次同步都需要进行计算比对，会带来额外的开销。

可以通过时间戳、版本号比对。重点是对数据做好顺序标记。也就是说快照里面有版本号，后面只是发送一个特别小的数据快照，携带版本号。比对时通过版本号比对，很快

防止攻击：

ip、网段限制、p2p，服务端不进行转发



群消息：通过异步队列完成消息的写扩散，群中每人都存一份消息。

服务和服务之间数据交互：同步（rpc）、异步（队列）



读扩散、写扩散：

feed流：好比把食物喂给某一个动物。用在有关注、粉丝的场景。如微博、微信、抖音

核心：关注、取关、发布feed、拉取feed

核心数据：好友关系、feed流数据。

拉取：读扩散

推送：写扩散

优点：数据存储结构简单

缺点：会有读性能问题以及热点数据问题。

热点数据的解决方案：写扩散

写扩散：推模式

写扩散除了和读扩散有关注和粉丝列表的存储以及自己发布的feed列表存储，还多了一部分存储：自己收到的feed列表。



微信是如何做到稳步发展的？

1. 极简的设计；越简单，越往后，可塑性就越强

2. 大系统小做

3. 业务监控：预防大于治疗，做监控中心，监控中心可做成jar包，程序中通过方法调用进行监控。

   ​	监控中心：收集数据，汇总数据判断阈值，告警。



国际化数据中心：

独立部署、数据互通

要进行数据同步，网络延迟可能会高，

如何保证网络高延迟的情况下，数据同步和使用不出问题？

pnuts方案：

1. 对用户进行切分；
2. 写在自己归属的数据中心（主从模式），多master之间，异步同步数据。

如何保证业务逻辑在这种数据弱一致性的情况下不会出现问题？

限制用户回自己归属数据中心。如果漫游，则指向回来。

涉及到多数据中心交互的场景，

如果数据实时性要求没那么高，出现短暂的数据一致性无所谓。

如果要求数据实时性很高，修改提示不是当时生效，系统可以提示过段时间生效，后台校验。可以考虑从业务上来解决这个问题。

还有要不然就是针对具体业务提供一个全球唯一的服务。

不能通过技术，来判断用户真正使用系统的数据中心

为了数据安全，必须同步。



两个数据中心之间数据的同步：两个目标：同步不出错，高效。

最朴素的方法：顺序、异步。

两地三中心：

保证数据的可用性、保证业务的连续性，保证安全性

两地：距离很远的两地，不会受到特大灾难同时发生的两地。

三中心：生产中心、灾备中心、备份中心，保证企业业务的连续性和数据安全。

异地多活：

两个标准：

1. 所有数据中心都提供服务；
2. 如果某个数据中心挂了，那么它所服务的用户可以通过别的数据中心提供服务。

同城异区（高速网络）

跨城异地（网络延迟，数据不能实时一致）

跨过异地（延迟更高）

异地多活设计：

设计角度：

1. 保证核心业务异地多活；

   日活1000w的系统，注册也就几万每天，修改信息几万每天。每天登录，可能1000w，而且针对注册和修改信息很难做到数据同步，如果出现故障还没来得及同步的话，可以使用版本号或者时间戳的方式进行最后的同步，但是无论如何都比较麻烦，相比下来，登录是核心业务，可以着重针对登录做异地多活。

2. 保证核心数据的最终一致性。

3. 允许多种手段同步数据。（同步、异步、主从、二次读取，重新生成）

4. 保证大部分用户

5. 技术无法解决，从业务入手

设计步骤：

1. 业务分级（访问量、业务使用、收益）
2. 数据分类（数据量、唯一、实时性、可丢失性、可恢复性）
3. 数据同步
4. 异常处理（多通道同步：Mysql主从和消息队列，使用不同网络，涉及到数据覆盖，后面的覆盖前面的、同步&访问结合，补偿机制）

 三园区容灾：

1. 同时提供服务。（解决了流量切换顺利的问题，资源闲置的问题）

   每个园区的服务资源跑在容量上限的2/3，保留了1/3的容量，如果某一个园区坏了，将流量分摊到另外两个园区，略不会突破每个园区服务器的极限。

2. 数据强一致。使用集群一主二从的方式解决三园区数据的一致性。
3. 故障自动切换。对故障服务的自动屏蔽和自动切换。

如何做：故障识别（通过失败阈值，时间内故障比例2种方案），故障切换（redirect），故障恢复

4. 容灾效果持续检验



朋友圈设计方案：

写扩散

朋友圈容灾：三园区都有容量剩余，且三个园区之间都有高速网络连接。并且做了主从架构，所以数据是无损的。跨园区、跨地域的容灾。



微信红包：

微信红包是微信支付的一个商户。

红包主要功能：

包：红包id、红包信息

发：微信支付成功，发消息给收红包的人，并且存入发红包的记录中。

抢：判断是否抢完，是否过期等。

拆：查询红包是不是够，计算金额，记录抢红包记录，转到微信支付。

查、

数据库设计：

![image-20241006144020515](https://gitee.com/zhf19970510/image-server/raw/master/img_2024/202410061440245.png)

两大业务特点：

1. 海量并发；
2. 资金交易不能错；

技术难点：

锁库存、下订单、更新库存。一个事务中。

常用方案：

1. 内存、缓存，同步数据库。不合适的。
2. 乐观锁。不适合

微信怎么做的？

1. set化。一系列集合（服务，存储）

将红包id进行分组，比如1-10的红包id进行系列1对应的server、db集合，11-20的红包id进行系列2对应的server、db集合。多个set之间相互独立。

2. 请求排队：

   必然有事务。如何不加锁，还能保证事务呢？ 串行。

   如何保证串行执行：控制队列的长度，memcached, redis 递增

3. 双维度 表设计。

   分表策略：id的hash，冷热分离（天）

4. 异步队列





总结：

分流、限流、导流





做系统三要素：

用户体验、性能、技术实现。

好项目是进化演化出来的。

