region：

通过heapRegion计算卡表大小

实时计算来判断新生代region的数量

region既是计算核心，也是内存管理的核心

优先回收价值高的区域

为了提高JVM运行效率，那么我们应该尽量减少临界区，避免全局锁。 TLAB
-XX:+UseTLAB		默认打开

TLAB上分配：快速分配。
TLAB之外分配：慢速分配。

慢速分配就是在堆内存中除TLAB之外的区域进行分配

TLAB是在Eden区开一小块区域


RSet(RememberSet) 引用集
两种方式记录引用关系：
obj1.方法 = obj2
point  Out: 记录的是obj1所在的Region所对应的Rset记录的是obj2的位置。
point  In：在obj2所在的Rset记录的是Obj1的位置。
g1 采用的是 point in的方式。
因为被引用方要记录引用放的位置，卡表的位置不够用了，所以引用集采用了三种数据结构去记录这种引用关系：
稀疏表
粗粒度位图
细粒度位图

MESI 缓存一致性协议
通过Store Buffer提升了硬件MESI缓存一致性的性能，同时它的写入乱序问题是通过写屏障来保证写的顺序的。

CPU缓存行大小 128Byte	1个卡表1字节， 可以放入128个卡表。
一个卡页 512字节， 128byte * 512 = 64 KB 数据
不同的线程对对象的引用操作，只要在同一个64KB之内，两个线程在更新同一个缓存行的数据，会导致缓存写回无效化或者同步操作，这也就是内存伪共享问题。
明明内存不是共享的，但是由于在同一个cpu缓存行当中，强行让它共享。会有问题
解决方案：
在写屏障中添加条件，先检查卡表的标记是不是脏卡，只有未被标记才标记为脏卡。
避免并发写卡表，导致内存伪共享问题。


young gc：回收新生代
mixed gc：全部新生代以及部分老年代
full gc：所有新生代以及老年代